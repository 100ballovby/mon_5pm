<h1>Конспект «Объекты».</h1>
<h2>Создание объекта</h2>

<p>Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Каждый элемент сопоставлен со своим
    ключом и порядок элементов совсем неважен.</p>
<p>Ключи в объекте следует делать уникальными. Если в одном объекте
    несколько одинаковых ключей, то используется значение последнего.</p>
<p>Несколько правил синтаксиса:</p>
<ul>
    <li>Ключ обособляется от значения двоеточием.</li>
    <li>Пары «ключ-значение» отделяются друг от друга запятыми.</li>
    <li>Значениями могут быть данные любого типа (число, строка, массив и так далее).</li>
</ul>
<pre><code>
let user = {
  name: 'Егор',
  age: 8
};
</code></pre>

<h2>Чтение из объекта</h2>

<p>Чтобы получить значение свойства, к нему надо обратиться через точку <code>объект.ключ</code>.
    Такая запись называется <i>точечной нотацией</i> и возвращает значение свойства объекта, если такое свойство есть. В
    противном случае вы получите <code>undefined</code>, то есть ничего.</p>
<pre><code>
    console.log(<mark>user.name</mark>); // Выведет в консоль: Егор
    console.log(<mark>user.age</mark>); // Выведет в консоль: 8
    console.log(<mark>user.color</mark>); // Выведет: undefined. Такого ключа в объекте нет
</code></pre>

<h2>Запись в объект</h2>

<p>Свойства объектов можно не только читать, но и переопределять, как и обычные переменные. А ещё в
    объект можно добавлять новые свойства уже после того, как он был создан.</p>
<pre><code>
    <mark>user.age++;</mark> // Увеличили возраст пользователя на 1
    console.log(user.age) // Выведет: 9
    <mark>user.name = 'Рокки';</mark> // Заменили снаружи значение свойства name
    console.log(user.name); // Выведет: Рокки
    <mark>user.color = 'рыжий';</mark> // Добавили в объект новое свойство
    console.log(user.color); // Выведет: рыжий
</code></pre>

<h2>Передача по ссылке</h2>
<p>Объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую
    отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из
    переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать
    или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — <i>передача объектов по
        ссылке</i>.</p>
<pre><code>
let first_user = {
  name: 'Егор',
  age: 8
};

let second_user = first_user;
console.log(second_user); // Выведет: {name: "Кекс", age:5}

first_user.name = 'Олег';
console.log(second_user); // Выведет: {name: "Олег", age:5}
</code></pre>

<h2>Методы объекта</h2>
<p>В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами
    объектов. Вызов метода записывается так: объект.метод ().</p>

<pre><code>
let user = {
  name: 'Егор',
  color: 'рыжий',
  age: 8,
  getGreeting: function() {
    return 'Привет!';
  }
};
console.log(user.getGreeting()); // Выведет: Привет!
</code></pre>

<h2>Скобочная нотация</h2>

<p>Прочитать свойство из объекта можно с помощью квадратных скобок: <code>usersFavoriteFood[name]</code>. Способ со
    скобками называется <i>скобочной</i> нотацией, способ с точкой — <i>точечной</i> нотацией.</p><p>Скобочная нотация
    намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в
    переменную:</p>

<pre><code>
let name = 'Егор';
let usersFavoriteFood = { 'Егор': 'чипсы' };
console.log(usersFavoriteFood.name); // Выведет: undefined
console.log(usersFavoriteFood[name]); // Выведет: чипсы
</code></pre>

<p>Первое сообщение содержит <code>undefined</code>, потому что у объекта нет свойства <code>name</code>. Второе
    сообщение содержит искомое значение, потому что программа понимает, что в квадратных скобках переменная. Значение
    переменной подставится в скобки, а затем будет найдено нужное свойство объекта.</p>
<p>В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие
    свойства прочитать не получится, а со скобочной — без проблем.</p>
<pre><code>
let user = { 'favorite food': 'Сыр' };
// Вызовет ошибку
console.log(user.favorite food);
// Отработает нормально
console.log(user['favorite food']);
</code></pre>

<h2>Объект как словарь</h2>
<p>Словари, или мапы, очень удобны в использовании. В нашем примере они хранят соотношение имени пользователя и лакомства, которое по вкусу именно ему.</p>
<pre><code>
let usersFavoriteFood = {
  Егор: 'рыба',
  Олег: 'котлета',
  Паша: 'пицца'
};
let printFavoriteFood = function (name) {
  // Используем скобочную нотацию
  return 'Моя любимая еда — ' + <b>usersFavoriteFood<mark>[name]</mark></b>;
};
console.log(printFavoriteFood('Паша')); // Выведет: Моя любимая еда — пицца</code></pre>

<h2>this</h2>

<p>Изнутри методов можно обращаться к свойствам и другим методам объекта с помощью ключевого слова <code>this</code>. Оно 
    указывает на текущий объект и называется <i>контекстом вызова</i>.</p>
<p>Важная деталь: пока функция не вызвана, <code>this</code> не содержит никакого значения, контекст 
    появляется только в момент вызова функции.</p>
<pre><code>
let user = {
    name: 'Егор',
    color: 'рыжий',
    age: 8,
    getGreeting: function() {
        return 'Привет! Меня зовут ' + <mark>this.name</mark>;
    }
};
console.log(<mark>user.getGreeting()</mark>); // Выведет: Привет! Меня зовут Егор
</code></pre>
